package authn

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"math"
	"net"
	"testing"
	"time"

	"github.com/libp2p/go-libp2p-core/host"
	"github.com/libp2p/go-libp2p-core/peerstore"
	"github.com/libp2p/go-libp2p-core/protocol"
	"github.com/multiformats/go-multiaddr"
	"github.com/status-im/go-waku/tests"
	"github.com/stretchr/testify/require"
	"github.com/xmtp/go-msgio/protoio"
	"github.com/xmtp/xmtp-node-go/logging"
	pb2 "github.com/xmtp/xmtp-node-go/pb"
	"github.com/xmtp/xmtp-node-go/types"
	"go.uber.org/zap"
	"google.golang.org/protobuf/proto"
)

type testCase struct {
	peerID     string
	walletAddr string
	reqBytes   string
}

// Sample AuthRequests are generated by exporting serialized bytes from a reference implementation (xmtp-js).
// Tests failures which use these as a source of truth are an indication of broken backwards compatibility with the SDK.
var (
	sampleAuthReq001 = testCase{
		peerID:     "QmVfhr7T4DvBnWgWYKF4kj73LA9gxoyp9oXgL9sUmG7SwZ",
		walletAddr: "0x63A599EA07c523dB7fC53422350b5Dc0A69bAfa8",
		reqBytes:   "0ac1020a4c089dfbf2ff95301a430a410402c114f86731766f4d89dd0e0d63c4bc493dee71c63b0e5eb8f865d662debb3c47ee204652cbbd6ee25fdaadd07c341b4a454fda20b92d96ae97bb85ec4b7a3612440a420a405f43b42c11de137772802804353f148959a37b381ca955202a07e6adea09c44b452af48276b0a45974ea78a43efb5a6269a42ca5723b40d0c2b84ab035a51e901a630a2a307836334135393945413037633532336442376643353334323233353062354463304136396241666138122e516d566668723754344476426e576757594b46346b6a37334c413967786f7970396f58674c3973556d473753775a18a4fdf2ff953022460a440a4032b90a244a3442825f47b7f3bc21cbda78b518ac914b9568fd0a208559fcc8326ca887f538bdfaa10eca8fdda6bfe299dfab1c3c718d942c644f096cf0ac78ac1001",
	}

	sampleAuthReq002 = testCase{
		peerID:     "QmfNjjEotVgJThmd8TKkKVMDHJ1BFvS99vaHdHsLk5Xhsy",
		walletAddr: "0x9997a0890Dad1E14d1E4F278d8Fde501eD21b94F",
		reqBytes:   "0abf020a4c08bebb8f8096301a430a4104d04d4cc9588d98039db2ab046649edc4239832c6659040f1e15030c61b54e95887a64cae48a1fc47285ec07ac460444ededc38d41be98941829b57c8b84ea84312440a420a406bd28720cadc85f397d8a81459d8c5ef0d7d840127e15b3e8e9d7e030d71fedd130f4fe6d7fda9ddac3250ccae31a029ffe3c7b07fdd7f10bf6f6d2a02c8d5f21a630a2a307839393937613038393044616431453134643145344632373864384664653530316544323162393446122e516d664e6a6a456f7456674a54686d6438544b6b4b564d44484a314246765339397661486448734c6b355868737918c7bd8f80963022440a420a40d896755b06fdaad912ef1e58ad197e6ce68c00afd3c9fd8f0eaf3ea49b9027632c22c7d3aa168875eead1fbde1ca3810be18ee22b4fa19cf9fde643c74f30a49",
	}
)

func LoadSerializedAuthReq(str string) (*pb2.V1ClientAuthRequest, error) {
	serializedAuthReq, _ := hex.DecodeString(str)

	authReq := &pb2.ClientAuthRequest{}
	err := proto.Unmarshal(serializedAuthReq, authReq)
	if err != nil {
		return nil, err
	}

	req := authReq.GetV1()

	return req, nil
}

func CreateHost(ctx context.Context, log *zap.Logger) (host.Host, error) {
	maxAttempts := 5
	hostStr := "localhost"
	port := 0

	for i := 0; i < maxAttempts; i++ {
		addr, err := net.ResolveTCPAddr("tcp", net.JoinHostPort(hostStr, "0"))
		if err != nil {
			log.Error("unable to resolve tcp addr: %v", zap.Error(err))
			continue
		}
		l, err := net.ListenTCP("tcp", addr)
		if err != nil {
			log.Error("unable to listen on addr %q: %v", zap.String("ipaddr", addr.String()), zap.Error(err))
			err := l.Close()
			if err != nil {
				return nil, err
			}
			continue
		}

		port = l.Addr().(*net.TCPAddr).Port
		err = l.Close()
		if err != nil {
			return nil, err
		}

	}

	libP2pHost, err := tests.MakeHost(ctx, port, rand.Reader)
	if err != nil {
		return nil, err
	}

	return libP2pHost, nil
}

func CreateNode(ctx context.Context, log *zap.Logger) (*XmtpAuthentication, error) {

	libP2pHost, err := CreateHost(ctx, log)
	if err != nil {
		return nil, err
	}

	return NewXmtpAuthentication(ctx, libP2pHost, log), nil
}

func ClientAuth(ctx context.Context, log *zap.Logger, h host.Host, peerId types.PeerId, dest multiaddr.Multiaddr, protoId protocol.ID, serializedRequest string) (bool, error) {
	h.Peerstore().AddAddr(peerId.Raw(), dest, peerstore.PermanentAddrTTL)

	err := h.Connect(ctx, h.Peerstore().PeerInfo(peerId.Raw()))
	if err != nil {
		log.Error("host could not connect", zap.Error(err))
		return false, err
	}

	stream, err := h.NewStream(ctx, peerId.Raw(), protoId)
	if err != nil {
		log.Info("", zap.Error(err))
		return false, err
	}

	v1, _ := LoadSerializedAuthReq(serializedRequest)
	authReqRPC := &pb2.ClientAuthRequest{
		Version: &pb2.ClientAuthRequest_V1{
			V1: v1,
		},
	}

	log.Info("REQ", zap.Any("pack", authReqRPC))

	writer := protoio.NewDelimitedWriter(stream)
	reader := protoio.NewDelimitedReader(stream, math.MaxInt32)

	err = writer.WriteMsg(authReqRPC)
	if err != nil {
		log.Error("could not write request", zap.Error(err))
		return false, err
	}

	authResponseRPC := &pb2.ClientAuthResponse{}
	err = reader.ReadMsg(authResponseRPC)
	if err != nil {
		log.Error("could not read response", zap.Error(err))
		return false, err
	}

	return authResponseRPC.GetV1().AuthSuccessful, nil
}

// This integration test checks that data can flow between a mock client and Auth protocol. As the authn request was
// generated from an oracle the peerIDs between the saved request and the connecting stream will not match, resulting in
// a failed authentication.
func TestRoundTrip(t *testing.T) {

	log, _ := zap.NewDevelopment()

	ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
	node, err := CreateNode(ctx, log)
	if err != nil {
		log.Error("Test node could not be created", zap.Error(err))
		cancel()
		return
	}
	client, err := CreateHost(ctx, log)
	if err != nil {
		log.Error("Test client could not be created", zap.Error(err))
		cancel()
		return
	}

	go func() {
		node.Start()
		require.NoError(t, err)
		dest := node.h.Addrs()[0]

		didSucceed, err := ClientAuth(ctx, log.Named("MockClient"), client, types.PeerId(node.h.ID()), dest, TransportAuthID_v01beta1, sampleAuthReq002.reqBytes)
		require.NoError(t, err)
		require.False(t, didSucceed)

		cancel()
	}()
	<-ctx.Done()

}

func TestV1_Nominal(t *testing.T) {
	logger, _ := zap.NewDevelopment()
	ctx := logging.With(context.Background(), logger)

	testCase := sampleAuthReq001

	expectedPeerId := types.PeerId(testCase.peerID)
	expectedWalletAddr := types.WalletAddr(testCase.walletAddr)

	req, err := LoadSerializedAuthReq(testCase.reqBytes)
	require.NoError(t, err)

	authData, err := unpackAuthData(req.AuthDataBytes)
	require.NoError(t, err)

	require.Equal(t, expectedWalletAddr, types.WalletAddr(authData.WalletAddr), "bad deserialized wallet address")
	require.Equal(t, expectedPeerId, types.PeerId(authData.PeerId), "bad deserialized peerID")

	peerId, walletAddr, err := validateRequest(ctx, req, expectedPeerId)
	require.NoError(t, err)

	require.Equal(t, expectedWalletAddr, walletAddr, "wallet address mismatch")
	require.Equal(t, expectedPeerId, peerId, "peerID mismatch")

}

func TestV1_BadAuthSig(t *testing.T) {
	logger, _ := zap.NewDevelopment()
	ctx := logging.With(context.Background(), logger)

	connectingPeerId := types.PeerId("TestPeerID")
	req, err := LoadSerializedAuthReq(sampleAuthReq001.reqBytes)
	require.NoError(t, err)

	authData, err := unpackAuthData(req.AuthDataBytes)
	require.NoError(t, err)

	authData.WalletAddr = "0000000"
	req.AuthDataBytes, _ = proto.Marshal(authData)

	_, _, err = validateRequest(ctx, req, connectingPeerId)
	require.Error(t, err)
}

func TestV1_PeerIdSpoof(t *testing.T) {
	logger, _ := zap.NewDevelopment()
	ctx := logging.With(context.Background(), logger)

	req, err := LoadSerializedAuthReq(sampleAuthReq001.reqBytes)
	require.NoError(t, err)
	connectingPeerId := types.PeerId("InvalidPeerID")

	_, _, err = validateRequest(ctx, req, connectingPeerId)
	require.Error(t, err)
}

func TestV1_SignatureMismatch(t *testing.T) {
	logger, _ := zap.NewDevelopment()
	ctx := logging.With(context.Background(), logger)

	req1, err := LoadSerializedAuthReq(sampleAuthReq001.reqBytes)
	require.NoError(t, err)
	req2, err := LoadSerializedAuthReq(sampleAuthReq002.reqBytes)
	require.NoError(t, err)

	authData1, err := unpackAuthData(req1.AuthDataBytes)
	require.NoError(t, err)
	authData2, err := unpackAuthData(req2.AuthDataBytes)
	require.NoError(t, err)

	// Nominal Checks
	_, _, err = validateRequest(ctx, req1, types.PeerId(authData1.PeerId))
	require.NoError(t, err)
	_, _, err = validateRequest(ctx, req2, types.PeerId(authData2.PeerId))
	require.NoError(t, err)

	// Swap Signatures to check for valid but mismatched signatures
	req1.WalletSignature = req2.WalletSignature
	req2.AuthSignature = req1.AuthSignature

	// Expect Errors as the derived walletAddr will not match the one supplied in AuthData
	_, _, err = validateRequest(ctx, req1, types.PeerId(authData1.PeerId))
	require.Error(t, err)
	_, _, err = validateRequest(ctx, req2, types.PeerId(authData2.PeerId))
	require.Error(t, err)
}
