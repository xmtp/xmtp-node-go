// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: queries.sql

package queries

import (
	"context"
)

const getAllInboxLogs = `-- name: GetAllInboxLogs :many
SELECT sequence_id, inbox_id, server_timestamp_ns, identity_update_proto FROM inbox_log
WHERE inbox_id = $1
ORDER BY sequence_id ASC FOR UPDATE
`

func (q *Queries) GetAllInboxLogs(ctx context.Context, inboxID string) ([]InboxLog, error) {
	rows, err := q.db.QueryContext(ctx, getAllInboxLogs, inboxID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InboxLog
	for rows.Next() {
		var i InboxLog
		if err := rows.Scan(
			&i.SequenceID,
			&i.InboxID,
			&i.ServerTimestampNs,
			&i.IdentityUpdateProto,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInboxLogs = `-- name: GetInboxLogs :many
WITH b (inbox_id, sequence_id) AS (VALUES ($1))
SELECT a.sequence_id, a.inbox_id, a.server_timestamp_ns, a.identity_update_proto FROM inbox_log as a
JOIN b ON a.inbox_id = b.inbox_id
WHERE a.sequence_id > b.sequence_id
ORDER BY a.sequence_id ASC
`

func (q *Queries) GetInboxLogs(ctx context.Context, filters interface{}) ([]InboxLog, error) {
	rows, err := q.db.QueryContext(ctx, getInboxLogs, filters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []InboxLog
	for rows.Next() {
		var i InboxLog
		if err := rows.Scan(
			&i.SequenceID,
			&i.InboxID,
			&i.ServerTimestampNs,
			&i.IdentityUpdateProto,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
