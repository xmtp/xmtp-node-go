// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package queries

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const countDeletableGroupMessages = `-- name: CountDeletableGroupMessages :one
SELECT COUNT(*)
FROM group_messages
WHERE
    is_commit = false
    AND
    created_at < NOW() - make_interval(days := $1)
`

func (q *Queries) CountDeletableGroupMessages(ctx context.Context, ageDays int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countDeletableGroupMessages, ageDays)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrUpdateInstallation = `-- name: CreateOrUpdateInstallation :exec
INSERT INTO installations(id, created_at, updated_at, key_package)
	VALUES ($1, $2, $3, $4)
ON CONFLICT (id)
	DO UPDATE SET
		key_package = $4,
		updated_at = $3
`

type CreateOrUpdateInstallationParams struct {
	ID         []byte
	CreatedAt  int64
	UpdatedAt  int64
	KeyPackage []byte
}

func (q *Queries) CreateOrUpdateInstallation(ctx context.Context, arg CreateOrUpdateInstallationParams) error {
	_, err := q.db.ExecContext(ctx, createOrUpdateInstallation,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.KeyPackage,
	)
	return err
}

const deleteOldGroupMessagesBatch = `-- name: DeleteOldGroupMessagesBatch :many
WITH to_delete AS (
    SELECT id
    FROM group_messages
    WHERE is_commit = false
      AND created_at < NOW() - make_interval(days := $1)
    ORDER BY id
    LIMIT $2
    FOR UPDATE SKIP LOCKED
            )
DELETE FROM group_messages gm
    USING to_delete td
WHERE gm.id = td.id
    RETURNING gm.id, gm.created_at
`

type DeleteOldGroupMessagesBatchParams struct {
	AgeDays   int32
	BatchSize int32
}

type DeleteOldGroupMessagesBatchRow struct {
	ID        int64
	CreatedAt time.Time
}

func (q *Queries) DeleteOldGroupMessagesBatch(ctx context.Context, arg DeleteOldGroupMessagesBatchParams) ([]DeleteOldGroupMessagesBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, deleteOldGroupMessagesBatch, arg.AgeDays, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeleteOldGroupMessagesBatchRow
	for rows.Next() {
		var i DeleteOldGroupMessagesBatchRow
		if err := rows.Scan(&i.ID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const deleteOldWelcomeMessagesBatch = `-- name: DeleteOldWelcomeMessagesBatch :many
WITH to_delete AS (
    SELECT id
    FROM welcome_messages
    WHERE created_at < NOW() - make_interval(days := $1)
    ORDER BY id
    LIMIT $2
    FOR UPDATE SKIP LOCKED
            )
DELETE FROM welcome_messages wm
    USING to_delete td
WHERE wm.id = td.id
    RETURNING wm.id, wm.created_at
`

type DeleteOldWelcomeMessagesBatchParams struct {
	AgeDays   int32
	BatchSize int32
}

type DeleteOldWelcomeMessagesBatchRow struct {
	ID        int64
	CreatedAt time.Time
}

func (q *Queries) DeleteOldWelcomeMessagesBatch(ctx context.Context, arg DeleteOldWelcomeMessagesBatchParams) ([]DeleteOldWelcomeMessagesBatchRow, error) {
	rows, err := q.db.QueryContext(ctx, deleteOldWelcomeMessagesBatch, arg.AgeDays, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DeleteOldWelcomeMessagesBatchRow
	for rows.Next() {
		var i DeleteOldWelcomeMessagesBatchRow
		if err := rows.Scan(&i.ID, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchKeyPackages = `-- name: FetchKeyPackages :many
SELECT
	id,
	key_package
FROM
	installations
WHERE
	id = ANY ($1::BYTEA[])
`

type FetchKeyPackagesRow struct {
	ID         []byte
	KeyPackage []byte
}

func (q *Queries) FetchKeyPackages(ctx context.Context, installationIds [][]byte) ([]FetchKeyPackagesRow, error) {
	rows, err := q.db.QueryContext(ctx, fetchKeyPackages, pq.Array(installationIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FetchKeyPackagesRow
	for rows.Next() {
		var i FetchKeyPackagesRow
		if err := rows.Scan(&i.ID, &i.KeyPackage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAddressLogs = `-- name: GetAddressLogs :many
SELECT
	a.address,
	encode(a.inbox_id, 'hex') AS inbox_id,
	a.association_sequence_id
FROM
	address_log a
	INNER JOIN (
		SELECT
			address,
			MAX(association_sequence_id) AS max_association_sequence_id
		FROM
			address_log
		WHERE
			address = ANY ($1::TEXT[])
			AND revocation_sequence_id IS NULL
		GROUP BY
			address) b ON a.address = b.address
	AND a.association_sequence_id = b.max_association_sequence_id
`

type GetAddressLogsRow struct {
	Address               string
	InboxID               string
	AssociationSequenceID sql.NullInt64
}

func (q *Queries) GetAddressLogs(ctx context.Context, addresses []string) ([]GetAddressLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAddressLogs, pq.Array(addresses))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAddressLogsRow
	for rows.Next() {
		var i GetAddressLogsRow
		if err := rows.Scan(&i.Address, &i.InboxID, &i.AssociationSequenceID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGroupMessages = `-- name: GetAllGroupMessages :many
SELECT
	id, created_at, group_id, data, group_id_data_hash, is_commit
FROM
	group_messages
ORDER BY
	id ASC
`

func (q *Queries) GetAllGroupMessages(ctx context.Context) ([]GroupMessage, error) {
	rows, err := q.db.QueryContext(ctx, getAllGroupMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupMessage
	for rows.Next() {
		var i GroupMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.GroupID,
			&i.Data,
			&i.GroupIDDataHash,
			&i.IsCommit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllInboxLogs = `-- name: GetAllInboxLogs :many
SELECT
	sequence_id,
	encode(inbox_id, 'hex') AS inbox_id,
	identity_update_proto
FROM
	inbox_log
WHERE
	inbox_id = decode($1, 'hex')
ORDER BY
	sequence_id ASC
`

type GetAllInboxLogsRow struct {
	SequenceID          int64
	InboxID             string
	IdentityUpdateProto []byte
}

func (q *Queries) GetAllInboxLogs(ctx context.Context, inboxID string) ([]GetAllInboxLogsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllInboxLogs, inboxID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllInboxLogsRow
	for rows.Next() {
		var i GetAllInboxLogsRow
		if err := rows.Scan(&i.SequenceID, &i.InboxID, &i.IdentityUpdateProto); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllWelcomeMessages = `-- name: GetAllWelcomeMessages :many
SELECT
	id, created_at, installation_key, data, hpke_public_key, installation_key_data_hash, wrapper_algorithm, welcome_metadata
FROM
	welcome_messages
ORDER BY
	id ASC
`

func (q *Queries) GetAllWelcomeMessages(ctx context.Context) ([]WelcomeMessage, error) {
	rows, err := q.db.QueryContext(ctx, getAllWelcomeMessages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WelcomeMessage
	for rows.Next() {
		var i WelcomeMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.InstallationKey,
			&i.Data,
			&i.HpkePublicKey,
			&i.InstallationKeyDataHash,
			&i.WrapperAlgorithm,
			&i.WelcomeMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInboxLogFiltered = `-- name: GetInboxLogFiltered :many
SELECT
	a.sequence_id,
	encode(a.inbox_id, 'hex') AS inbox_id,
	a.identity_update_proto,
	a.server_timestamp_ns
FROM
	inbox_log AS a
	JOIN (
		SELECT
			inbox_id, sequence_id
		FROM
			json_populate_recordset(NULL::inbox_filter, $1) AS b(inbox_id,
				sequence_id)) AS b ON decode(b.inbox_id, 'hex') = a.inbox_id::BYTEA
		AND a.sequence_id > b.sequence_id
	ORDER BY
		a.sequence_id ASC
`

type GetInboxLogFilteredRow struct {
	SequenceID          int64
	InboxID             string
	IdentityUpdateProto []byte
	ServerTimestampNs   int64
}

func (q *Queries) GetInboxLogFiltered(ctx context.Context, filters json.RawMessage) ([]GetInboxLogFilteredRow, error) {
	rows, err := q.db.QueryContext(ctx, getInboxLogFiltered, filters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetInboxLogFilteredRow
	for rows.Next() {
		var i GetInboxLogFilteredRow
		if err := rows.Scan(
			&i.SequenceID,
			&i.InboxID,
			&i.IdentityUpdateProto,
			&i.ServerTimestampNs,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getInstallation = `-- name: GetInstallation :one
SELECT
	id,
	created_at,
	updated_at,
	key_package
FROM
	installations
WHERE
	id = $1
`

func (q *Queries) GetInstallation(ctx context.Context, id []byte) (Installation, error) {
	row := q.db.QueryRowContext(ctx, getInstallation, id)
	var i Installation
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.KeyPackage,
	)
	return i, err
}

const getOldWelcomeMessages = `-- name: GetOldWelcomeMessages :one
SELECT COUNT(*)::bigint as old_message_count
FROM welcome_messages
WHERE created_at < NOW() - make_interval(days := $1)
`

func (q *Queries) GetOldWelcomeMessages(ctx context.Context, ageDays int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getOldWelcomeMessages, ageDays)
	var old_message_count int64
	err := row.Scan(&old_message_count)
	return old_message_count, err
}

const insertAddressLog = `-- name: InsertAddressLog :one
INSERT INTO address_log(address, inbox_id, association_sequence_id, revocation_sequence_id)
	VALUES ($1, decode($2, 'hex'), $3, $4)
RETURNING
	address, inbox_id, association_sequence_id, revocation_sequence_id
`

type InsertAddressLogParams struct {
	Address               string
	InboxID               string
	AssociationSequenceID sql.NullInt64
	RevocationSequenceID  sql.NullInt64
}

func (q *Queries) InsertAddressLog(ctx context.Context, arg InsertAddressLogParams) (AddressLog, error) {
	row := q.db.QueryRowContext(ctx, insertAddressLog,
		arg.Address,
		arg.InboxID,
		arg.AssociationSequenceID,
		arg.RevocationSequenceID,
	)
	var i AddressLog
	err := row.Scan(
		&i.Address,
		&i.InboxID,
		&i.AssociationSequenceID,
		&i.RevocationSequenceID,
	)
	return i, err
}

const insertCommitLog = `-- name: InsertCommitLog :one
SELECT
	id, created_at, group_id, encrypted_entry
FROM
	insert_commit_log($1, $2)
`

type InsertCommitLogParams struct {
	GroupID        []byte
	EncryptedEntry []byte
}

func (q *Queries) InsertCommitLog(ctx context.Context, arg InsertCommitLogParams) (CommitLog, error) {
	row := q.db.QueryRowContext(ctx, insertCommitLog, arg.GroupID, arg.EncryptedEntry)
	var i CommitLog
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.GroupID,
		&i.EncryptedEntry,
	)
	return i, err
}

const insertGroupMessage = `-- name: InsertGroupMessage :one
SELECT
	id, created_at, group_id, data, group_id_data_hash, is_commit
FROM
    insert_group_message_with_is_commit($1, $2, $3, $4)
`

type InsertGroupMessageParams struct {
	GroupID         []byte
	Data            []byte
	GroupIDDataHash []byte
	IsCommit        bool
}

func (q *Queries) InsertGroupMessage(ctx context.Context, arg InsertGroupMessageParams) (GroupMessage, error) {
	row := q.db.QueryRowContext(ctx, insertGroupMessage,
		arg.GroupID,
		arg.Data,
		arg.GroupIDDataHash,
		arg.IsCommit,
	)
	var i GroupMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.GroupID,
		&i.Data,
		&i.GroupIDDataHash,
		&i.IsCommit,
	)
	return i, err
}

const insertInboxLog = `-- name: InsertInboxLog :one
SELECT
	sequence_id
FROM
	insert_inbox_log(decode($1, 'hex'), $2, $3)
`

type InsertInboxLogParams struct {
	InboxID             string
	ServerTimestampNs   int64
	IdentityUpdateProto []byte
}

func (q *Queries) InsertInboxLog(ctx context.Context, arg InsertInboxLogParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertInboxLog, arg.InboxID, arg.ServerTimestampNs, arg.IdentityUpdateProto)
	var sequence_id int64
	err := row.Scan(&sequence_id)
	return sequence_id, err
}

const insertWelcomeMessage = `-- name: InsertWelcomeMessage :one
SELECT
	id, created_at, installation_key, data, hpke_public_key, installation_key_data_hash, wrapper_algorithm, welcome_metadata
FROM
	insert_welcome_message_v4($1, $2, $3, $4, $5, $6)
`

type InsertWelcomeMessageParams struct {
	InstallationKey         []byte
	Data                    []byte
	InstallationKeyDataHash []byte
	HpkePublicKey           []byte
	WrapperAlgorithm        int16
	WelcomeMetadata         []byte
}

func (q *Queries) InsertWelcomeMessage(ctx context.Context, arg InsertWelcomeMessageParams) (WelcomeMessage, error) {
	row := q.db.QueryRowContext(ctx, insertWelcomeMessage,
		arg.InstallationKey,
		arg.Data,
		arg.InstallationKeyDataHash,
		arg.HpkePublicKey,
		arg.WrapperAlgorithm,
		arg.WelcomeMetadata,
	)
	var i WelcomeMessage
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.InstallationKey,
		&i.Data,
		&i.HpkePublicKey,
		&i.InstallationKeyDataHash,
		&i.WrapperAlgorithm,
		&i.WelcomeMetadata,
	)
	return i, err
}

const lockInboxLog = `-- name: LockInboxLog :exec
SELECT
	pg_advisory_xact_lock(hashtext($1))
`

func (q *Queries) LockInboxLog(ctx context.Context, inboxID string) error {
	_, err := q.db.ExecContext(ctx, lockInboxLog, inboxID)
	return err
}

const queryCommitLog = `-- name: QueryCommitLog :many
SELECT
	id, created_at, group_id, encrypted_entry
FROM
	commit_log
WHERE
	group_id = $1
	AND id > $2
ORDER BY
	id ASC
LIMIT $3
`

type QueryCommitLogParams struct {
	GroupID []byte
	Cursor  int64
	Numrows int32
}

func (q *Queries) QueryCommitLog(ctx context.Context, arg QueryCommitLogParams) ([]CommitLog, error) {
	rows, err := q.db.QueryContext(ctx, queryCommitLog, arg.GroupID, arg.Cursor, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CommitLog
	for rows.Next() {
		var i CommitLog
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.GroupID,
			&i.EncryptedEntry,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryGroupMessages = `-- name: QueryGroupMessages :many
SELECT
	id, created_at, group_id, data, group_id_data_hash, is_commit
FROM
	group_messages
WHERE
	group_id = $1
ORDER BY
	CASE WHEN $2::BOOL THEN
		id
	END DESC,
	CASE WHEN $2::BOOL = FALSE THEN
		id
	END ASC
LIMIT $3
`

type QueryGroupMessagesParams struct {
	GroupID  []byte
	SortDesc bool
	Numrows  int32
}

func (q *Queries) QueryGroupMessages(ctx context.Context, arg QueryGroupMessagesParams) ([]GroupMessage, error) {
	rows, err := q.db.QueryContext(ctx, queryGroupMessages, arg.GroupID, arg.SortDesc, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupMessage
	for rows.Next() {
		var i GroupMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.GroupID,
			&i.Data,
			&i.GroupIDDataHash,
			&i.IsCommit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryGroupMessagesWithCursorAsc = `-- name: QueryGroupMessagesWithCursorAsc :many
SELECT
	id, created_at, group_id, data, group_id_data_hash, is_commit
FROM
	group_messages
WHERE
	group_id = $1
	AND id > $2
ORDER BY
	id ASC
LIMIT $3
`

type QueryGroupMessagesWithCursorAscParams struct {
	GroupID []byte
	Cursor  int64
	Numrows int32
}

func (q *Queries) QueryGroupMessagesWithCursorAsc(ctx context.Context, arg QueryGroupMessagesWithCursorAscParams) ([]GroupMessage, error) {
	rows, err := q.db.QueryContext(ctx, queryGroupMessagesWithCursorAsc, arg.GroupID, arg.Cursor, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupMessage
	for rows.Next() {
		var i GroupMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.GroupID,
			&i.Data,
			&i.GroupIDDataHash,
			&i.IsCommit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryGroupMessagesWithCursorDesc = `-- name: QueryGroupMessagesWithCursorDesc :many
SELECT
	id, created_at, group_id, data, group_id_data_hash, is_commit
FROM
	group_messages
WHERE
	group_id = $1
	AND id < $2
ORDER BY
	id DESC
LIMIT $3
`

type QueryGroupMessagesWithCursorDescParams struct {
	GroupID []byte
	Cursor  int64
	Numrows int32
}

func (q *Queries) QueryGroupMessagesWithCursorDesc(ctx context.Context, arg QueryGroupMessagesWithCursorDescParams) ([]GroupMessage, error) {
	rows, err := q.db.QueryContext(ctx, queryGroupMessagesWithCursorDesc, arg.GroupID, arg.Cursor, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GroupMessage
	for rows.Next() {
		var i GroupMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.GroupID,
			&i.Data,
			&i.GroupIDDataHash,
			&i.IsCommit,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryWelcomeMessages = `-- name: QueryWelcomeMessages :many
SELECT
	id, created_at, installation_key, data, hpke_public_key, installation_key_data_hash, wrapper_algorithm, welcome_metadata
FROM
	welcome_messages
WHERE
	installation_key = $1
ORDER BY
	CASE WHEN $2::BOOL THEN
		id
	END DESC,
	CASE WHEN $2::BOOL = FALSE THEN
		id
	END ASC
LIMIT $3
`

type QueryWelcomeMessagesParams struct {
	InstallationKey []byte
	SortDesc        bool
	Numrows         int32
}

func (q *Queries) QueryWelcomeMessages(ctx context.Context, arg QueryWelcomeMessagesParams) ([]WelcomeMessage, error) {
	rows, err := q.db.QueryContext(ctx, queryWelcomeMessages, arg.InstallationKey, arg.SortDesc, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WelcomeMessage
	for rows.Next() {
		var i WelcomeMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.InstallationKey,
			&i.Data,
			&i.HpkePublicKey,
			&i.InstallationKeyDataHash,
			&i.WrapperAlgorithm,
			&i.WelcomeMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryWelcomeMessagesWithCursorAsc = `-- name: QueryWelcomeMessagesWithCursorAsc :many
SELECT
	id, created_at, installation_key, data, hpke_public_key, installation_key_data_hash, wrapper_algorithm, welcome_metadata
FROM
	welcome_messages
WHERE
	installation_key = $1
	AND id > $2
ORDER BY
	id ASC
LIMIT $3
`

type QueryWelcomeMessagesWithCursorAscParams struct {
	InstallationKey []byte
	Cursor          int64
	Numrows         int32
}

func (q *Queries) QueryWelcomeMessagesWithCursorAsc(ctx context.Context, arg QueryWelcomeMessagesWithCursorAscParams) ([]WelcomeMessage, error) {
	rows, err := q.db.QueryContext(ctx, queryWelcomeMessagesWithCursorAsc, arg.InstallationKey, arg.Cursor, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WelcomeMessage
	for rows.Next() {
		var i WelcomeMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.InstallationKey,
			&i.Data,
			&i.HpkePublicKey,
			&i.InstallationKeyDataHash,
			&i.WrapperAlgorithm,
			&i.WelcomeMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryWelcomeMessagesWithCursorDesc = `-- name: QueryWelcomeMessagesWithCursorDesc :many
SELECT
	id, created_at, installation_key, data, hpke_public_key, installation_key_data_hash, wrapper_algorithm, welcome_metadata
FROM
	welcome_messages
WHERE
	installation_key = $1
	AND id < $2
ORDER BY
	id DESC
LIMIT $3
`

type QueryWelcomeMessagesWithCursorDescParams struct {
	InstallationKey []byte
	Cursor          int64
	Numrows         int32
}

func (q *Queries) QueryWelcomeMessagesWithCursorDesc(ctx context.Context, arg QueryWelcomeMessagesWithCursorDescParams) ([]WelcomeMessage, error) {
	rows, err := q.db.QueryContext(ctx, queryWelcomeMessagesWithCursorDesc, arg.InstallationKey, arg.Cursor, arg.Numrows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WelcomeMessage
	for rows.Next() {
		var i WelcomeMessage
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.InstallationKey,
			&i.Data,
			&i.HpkePublicKey,
			&i.InstallationKeyDataHash,
			&i.WrapperAlgorithm,
			&i.WelcomeMetadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeAddressFromLog = `-- name: RevokeAddressFromLog :exec
UPDATE
	address_log
SET
	revocation_sequence_id = $1
WHERE (address, inbox_id, association_sequence_id) =(
	SELECT
		address,
		inbox_id,
		MAX(association_sequence_id)
	FROM
		address_log AS a
	WHERE
		a.address = $2
		AND a.inbox_id = decode($3, 'hex')
	GROUP BY
		address,
		inbox_id)
`

type RevokeAddressFromLogParams struct {
	RevocationSequenceID sql.NullInt64
	Address              string
	InboxID              string
}

func (q *Queries) RevokeAddressFromLog(ctx context.Context, arg RevokeAddressFromLogParams) error {
	_, err := q.db.ExecContext(ctx, revokeAddressFromLog, arg.RevocationSequenceID, arg.Address, arg.InboxID)
	return err
}

const selectEnvelopesForIsCommitBackfill = `-- name: SelectEnvelopesForIsCommitBackfill :many
SELECT
    id, data
FROM
    group_messages
WHERE
    is_commit
        IS NULL
ORDER BY id ASC
FOR UPDATE SKIP LOCKED
LIMIT 100
`

type SelectEnvelopesForIsCommitBackfillRow struct {
	ID   int64
	Data []byte
}

func (q *Queries) SelectEnvelopesForIsCommitBackfill(ctx context.Context) ([]SelectEnvelopesForIsCommitBackfillRow, error) {
	rows, err := q.db.QueryContext(ctx, selectEnvelopesForIsCommitBackfill)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectEnvelopesForIsCommitBackfillRow
	for rows.Next() {
		var i SelectEnvelopesForIsCommitBackfillRow
		if err := rows.Scan(&i.ID, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const touchInbox = `-- name: TouchInbox :exec
INSERT INTO inboxes(id)
	VALUES (decode($1, 'hex'))
ON CONFLICT (id)
	DO UPDATE SET
		updated_at = NOW()
`

func (q *Queries) TouchInbox(ctx context.Context, inboxID string) error {
	_, err := q.db.ExecContext(ctx, touchInbox, inboxID)
	return err
}

const updateIsCommitStatus = `-- name: UpdateIsCommitStatus :exec
UPDATE
    group_messages
SET
    is_commit = $1
WHERE
    id = $2
`

type UpdateIsCommitStatusParams struct {
	IsCommit sql.NullBool
	ID       int64
}

func (q *Queries) UpdateIsCommitStatus(ctx context.Context, arg UpdateIsCommitStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateIsCommitStatus, arg.IsCommit, arg.ID)
	return err
}
